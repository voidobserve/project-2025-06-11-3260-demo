C51 COMPILER V9.60.7.0   AD_KEY                                                            12/09/2024 15:08:47 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AD_KEY
OBJECT MODULE PLACED IN .\Release\Objects\ad_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\ad_key.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) 
                    -INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware;..\..\Lowpower) INTERVAL(3) DEBUG OBJECTEXTEND P
                    -RINT(.\Release\Listings\ad_key.lst) OBJECT(.\Release\Objects\ad_key.obj)

line level    source

   1          #include "ad_key.h"
   2          
   3          
   4          //=======================================================//
   5          // æŒ‰é”®å€¼é‡æ–°æ˜ å°„å‡½æ•°:
   6          // ç”¨æˆ·å¯ä»¥å®ç°è¯¥å‡½æ•°æŠŠä¸€äº›æŒ‰é”®å€¼é‡æ–°æ˜ å°„, å¯ç”¨äºç»„åˆé”®çš„é”®å€¼é‡æ–°æ˜ å°„
   7          //=======================================================//
   8          // int __attribute__((weak)) key_event_remap(struct sys_event *e)
   9          // {
  10          //     return true;
  11          // }
  12          
  13          static volatile u8 is_key_active = 0;
  14          
  15          //=======================================================//
  16          // æŒ‰é”®æ‰«æå‡½æ•°: æ‰«ææ‰€æœ‰æ³¨å†Œçš„æŒ‰é”®é©±åŠ¨
  17          //=======================================================//
  18          static void key_driver_scan(void *_scan_para)
  19          {
  20   1          struct key_driver_para *scan_para = (struct key_driver_para *)_scan_para;
  21   1      
  22   1          u8 key_event = 0;
  23   1          u8 cur_key_value = NO_KEY;
  24   1          u8 key_value = 0;
  25   1          // struct sys_event e;
  26   1          static u8 poweron_cnt = 0;
  27   1      
  28   1          // ä¸ºäº†æ»¤æ‰adkeyä¸micè¿åœ¨ä¸€èµ·æ—¶ç”µå®¹å……æ”¾ç”µå¯¼è‡´çš„å¼€æœºæŒ‰é”®è¯¯åˆ¤,ä¸€èˆ¬ç”¨äºtype-c
             -è€³æœº
  29   1          /* if (poweron_cnt <= 250) { */
  30   1          /*     poweron_cnt++; */
  31   1          /*     return; */
  32   1          /* } */
  33   1      
  34   1          cur_key_value = scan_para->get_value();
  35   1          /* if (cur_key_value != NO_KEY) { */
  36   1          /*     printf(">>>cur_key_value: %d\n", cur_key_value); */
  37   1          /* } */
  38   1      
  39   1          if (cur_key_value != NO_KEY)
  40   1          {
  41   2              is_key_active = 35; // 35*10Ms
  42   2          }
  43   1          else if (is_key_active)
  44   1          {
  45   2              is_key_active--;
  46   2          }
  47   1      
  48   1          //===== æŒ‰é”®æ¶ˆæŠ–å¤„ç†
  49   1          if (cur_key_value != scan_para->filter_value && scan_para->filter_time)
  50   1          {                                            // å½“å‰æŒ‰é”®å€¼ä¸ä¸Šä¸€æ¬¡æŒ‰é”®å€¼å¦‚æœä¸ç›¸ç­‰, é
             -‡æ–°æ¶ˆæŠ–å¤„ç†, æ³¨æ„filter_time != 0;
  51   2              scan_para->filter_cnt = 0;               // æ¶ˆæŠ–æ¬¡æ•°æ¸…0, é‡æ–°å¼€å§‹æ¶ˆæŠ–
C51 COMPILER V9.60.7.0   AD_KEY                                                            12/09/2024 15:08:47 PAGE 2   

  52   2              scan_para->filter_value = cur_key_value; // è®°å½•ä¸Šä¸€æ¬¡çš„æŒ‰é”®å€¼
  53   2              return;                                  // ç¬¬ä¸€æ¬¡æ£€æµ‹, è¿”å›ä¸åšå¤„ç†
  54   2          } 
  55   1          
  56   1          // å½“å‰æŒ‰é”®å€¼ä¸ä¸Šä¸€æ¬¡æŒ‰é”®å€¼ç›¸ç­‰, filter_cntå¼€å§‹ç´¯åŠ ;
  57   1          if (scan_para->filter_cnt < scan_para->filter_time)
  58   1          {
  59   2              scan_para->filter_cnt++;
  60   2              return;
  61   2          }
  62   1      
  63   1          // ä¸ºäº†æ»¤æ‰adkeyä¸micè¿åœ¨ä¸€èµ·æ—¶ç”µå®¹å……æ”¾ç”µå¯¼è‡´çš„æŒ‰é”®è¯¯åˆ¤,ä¸€èˆ¬ç”¨äºtype-cè€³æœº
  64   1          /* if ((cur_key_value != scan_para->last_key) && (scan_para->last_key != NO_KEY) && (cur_key_value != 
             -NO_KEY)) { */
  65   1          /*     return; */
  66   1          /* } */
  67   1          
  68   1          //===== æŒ‰é”®æ¶ˆæŠ–ç»“æŸ, å¼€å§‹åˆ¤æ–­æŒ‰é”®ç±»å‹(å•å‡», åŒå‡», é•¿æŒ‰, å¤šå‡», HOLD, (é•¿æŒ‰/HOL
             -D)æŠ¬èµ·)
  69   1          if (cur_key_value != scan_para->last_key)
  70   1          {
  71   2              if (cur_key_value == NO_KEY)
  72   2              { // cur_key = NO_KEY; last_key = valid_key -> æŒ‰é”®è¢«æŠ¬èµ·
  73   3      
  74   3      #if MOUSE_KEY_SCAN_MODE
*** WARNING C322 IN LINE 74 OF ..\..\Hardware\ad_key.c: unknown identifier
                          /* if (scan_para->press_cnt >= scan_para->long_time) {  //é•¿æŒ‰/HOLDçŠ¶æ€ä¹‹åè¢«æŒ‰é”®æŠ¬è
             -µ·; */
                          key_event = KEY_EVENT_UP;
                          key_value = scan_para->last_key;
                          goto label_notify; // å‘é€æŠ¬èµ·æ¶ˆæ¯
                                        /* } */
              #else
  81   3                  if (scan_para->press_cnt >= scan_para->long_time)
  82   3                  { // é•¿æŒ‰/HOLDçŠ¶æ€ä¹‹åè¢«æŒ‰é”®æŠ¬èµ·;
  83   4                      key_event = KEY_EVENT_UP;
  84   4                      key_value = scan_para->last_key;
  85   4                      goto label_notify; // å‘é€æŠ¬èµ·æ¶ˆæ¯
  86   4                  }
  87   3      #endif
  88   3      
  89   3                  scan_para->click_delay_cnt = 1; // æŒ‰é”®ç­‰å¾…ä¸‹æ¬¡è¿å‡»å»¶æ—¶å¼€å§‹
  90   3              }
  91   2              else
  92   2              {                             // cur_key = valid_key, last_key = NO_KEY -> æŒ‰é”®è¢«æŒ‰ä¸‹
  93   3                  scan_para->press_cnt = 1; // ç”¨äºåˆ¤æ–­longå’Œholdäº‹ä»¶çš„è®¡æ•°å™¨é‡æ–°å¼€å§‹è®¡æ—¶;
  94   3                  if (cur_key_value != scan_para->notify_value)
  95   3                  { // ç¬¬ä¸€æ¬¡å•å‡»/è¿å‡»æ—¶æŒ‰ä¸‹çš„æ˜¯ä¸åŒæŒ‰é”®, å•å‡»æ¬¡æ•°é‡æ–°å¼€å§‹è®¡æ•°
  96   4                      scan_para->click_cnt = 1;
  97   4                      scan_para->notify_value = cur_key_value;
  98   4                  }
  99   3                  else
 100   3                  {
 101   4                      scan_para->click_cnt++; // å•å‡»æ¬¡æ•°ç´¯åŠ 
 102   4                  }
 103   3              }
 104   2              goto label_scan_end; // è¿”å›, ç­‰å¾…å»¶æ—¶æ—¶é—´åˆ°
 105   2          }
 106   1          else
 107   1          { // cur_key = last_key -> æ²¡æœ‰æŒ‰é”®æŒ‰ä¸‹/æŒ‰é”®é•¿æŒ‰(HOLD)
 108   2              if (cur_key_value == NO_KEY)
 109   2              { // last_key = NO_KEY; cur_key = NO_KEY -> æ²¡æœ‰æŒ‰é”®æŒ‰ä¸‹
C51 COMPILER V9.60.7.0   AD_KEY                                                            12/09/2024 15:08:47 PAGE 3   

 110   3                  if (scan_para->click_cnt > 0)
 111   3                  { // æœ‰æŒ‰é”®éœ€è¦æ¶ˆæ¯éœ€è¦å¤„ç†
 112   4      
 113   4      #if ALL_KEY_EVENT_CLICK_ONLY                 // å½©å±æ–¹æ¡ˆæ”¯æŒå•å‡»
*** WARNING C322 IN LINE 113 OF ..\..\Hardware\ad_key.c: unknown identifier
                              key_event = KEY_EVENT_CLICK; // å•å‡»
                              key_value = scan_para->notify_value;
                              goto label_notify;
              
              #endif
 119   4      
 120   4      #if KEY_EVENT_CLICK_ONLY_SUPPORT // æ˜¯å¦æ”¯æŒæŸäº›æŒ‰é”®åªå“åº”å•å‡»äº‹ä»¶
*** WARNING C322 IN LINE 120 OF ..\..\Hardware\ad_key.c: unknown identifier
                              if (scan_para->notify_value & BIT(7))
                              {                                // BIT(7)æŒ‰é”®ç‰¹æ®Šå¤„ç†æ ‡å¿—, åªå‘é€å•å‡»äº‹ä»¶,
             - ä¹Ÿå¯ä»¥ç”¨äºå…¶å®ƒæ‰©å±•
                                  key_event = KEY_EVENT_CLICK; // å•å‡»
                                  key_value = scan_para->notify_value;
                                  goto label_notify;
                              }
              #endif
 128   4                      if (scan_para->click_delay_cnt > scan_para->click_delay_time)
 129   4                      { // æŒ‰é”®è¢«æŠ¬èµ·åå»¶æ—¶åˆ°
 130   5                          // TODO: åœ¨æ­¤å¯ä»¥æ·»åŠ ä»»æ„å¤šå‡»äº‹ä»¶
 131   5                          if (scan_para->click_cnt >= 5)
 132   5                          {
 133   6                              key_event = KEY_EVENT_FIRTH_CLICK; // äº”å‡»
 134   6                          }
 135   5                          else if (scan_para->click_cnt >= 4)
 136   5                          {
 137   6                              key_event = KEY_EVENT_FOURTH_CLICK; // 4å‡»
 138   6                          }
 139   5                          else if (scan_para->click_cnt >= 3)
 140   5                          {
 141   6                              key_event = KEY_EVENT_TRIPLE_CLICK; // ä¸‰å‡»
 142   6                          }
 143   5                          else if (scan_para->click_cnt >= 2)
 144   5                          {
 145   6                              key_event = KEY_EVENT_DOUBLE_CLICK; // åŒå‡»
 146   6                          }
 147   5                          else
 148   5                          {
 149   6                              key_event = KEY_EVENT_CLICK; // å•å‡»
 150   6                          }
 151   5                          key_value = scan_para->notify_value;
 152   5                          goto label_notify;
 153   5                      }
 154   4                      else
 155   4                      { // æŒ‰é”®æŠ¬èµ·åç­‰å¾…ä¸‹æ¬¡å»¶æ—¶æ—¶é—´æœªåˆ°
 156   5                          scan_para->click_delay_cnt++;
 157   5                          goto label_scan_end; // æŒ‰é”®æŠ¬èµ·åå»¶æ—¶æ—¶é—´æœªåˆ°, è¿”å›
 158   5                      }
 159   4                  }
 160   3                  else
 161   3                  {
 162   4                      goto label_scan_end; // æ²¡æœ‰æŒ‰é”®éœ€è¦å¤„ç†
 163   4                  }
 164   3              }
 165   2              else
 166   2              { // last_key = valid_key; cur_key = valid_key, press_cntç´¯åŠ ç”¨äºåˆ¤æ–­longå’Œhold
 167   3                  scan_para->press_cnt++;
 168   3                  if (scan_para->press_cnt == scan_para->long_time)
C51 COMPILER V9.60.7.0   AD_KEY                                                            12/09/2024 15:08:47 PAGE 4   

 169   3                  {
 170   4                      key_event = KEY_EVENT_LONG;
 171   4                  }
 172   3                  else if (scan_para->press_cnt == scan_para->hold_time)
 173   3                  {
 174   4                      key_event = KEY_EVENT_HOLD;
 175   4                      scan_para->press_cnt = scan_para->long_time;
 176   4                  }
 177   3                  else
 178   3                  {
 179   4                      goto label_scan_end; // press_cntæ²¡åˆ°é•¿æŒ‰å’ŒHOLDæ¬¡æ•°, è¿”å›
 180   4                  }
 181   3                  // press_cntæ²¡åˆ°é•¿æŒ‰å’ŒHOLDæ¬¡æ•°, å‘æ¶ˆæ¯
 182   3                  key_value = cur_key_value;
 183   3                  goto label_notify;
 184   3              }
 185   2          }
 186   1      
 187   1      label_notify:
 188   1      #if TCFG_IRSENSOR_ENABLE
*** WARNING C322 IN LINE 188 OF ..\..\Hardware\ad_key.c: unknown identifier
                  if (get_irSensor_event() == IR_SENSOR_EVENT_FAR)
                  { // æœªä½©æˆ´çš„è€³æœºä¸å“åº”æŒ‰é”®
                      return;
                  }
              #endif
 194   1      
 195   1          //  å¦‚æœæ˜¯æ˜¯rfé¥æ§å™¨æŒ‰é”®å¯¹åº”çš„äº‹ä»¶
 196   1          // if (KEY_DRIVER_TYPE_RF == scan_para->key_type)
 197   1          {
 198   2              int msg = KEY_NULL; // å­˜æ”¾å¾…å‘é€çš„äº‹ä»¶ï¼ˆäº‹ä»¶æ¶ˆæ¯ï¼‰
 199   2      
 200   2              // å¦‚æœæ˜¯rfé¥æ§å™¨çš„æŒ‰é”®ï¼Œå‘æ£€æµ‹rfé¥æ§å™¨æŒ‰é”®çš„çº¿ç¨‹å‘é€æ¶ˆæ¯ï¼Œè€Œä¸æ˜¯å‘é
             -€ç³»ç»Ÿäº‹ä»¶
 201   2              // key_value &= ~BIT(7);   // BIT(7) ç”¨ä½œæŒ‰é”®ç‰¹æ®Šå¤„ç†çš„æ ‡å¿—
 202   2              // e.type = SYS_KEY_EVENT; // ç³»ç»ŸæŒ‰é”®äº‹ä»¶
 203   2              // e.u.key.init = 1;
 204   2              // e.u.key.type = scan_para->key_type; // åŒºåˆ†æŒ‰é”®ç±»å‹
 205   2              // e.u.key.event = key_event; // å­˜æ”¾æŒ‰é”®äº‹ä»¶ï¼ˆç”±ç³»ç»Ÿçš„æŒ‰é”®äº‹ä»¶æä¾›ï¼‰
 206   2              // e.u.key.value = key_value; // å­˜æ”¾å®é™…çš„é”®å€¼
 207   2              // e.u.key.tmr = timer_get_ms();
 208   2              scan_para->click_cnt = 0; // å•å‡»æ¬¡æ•°æ¸…0
 209   2              scan_para->notify_value = NO_KEY;
 210   2              // printf("key_value %u \nkey_event %d \n", key_value, key_event);
 211   2      
 212   2              // å‘é€æ¶ˆæ¯ç»™åˆ°è‡ªå·±çš„çº¿ç¨‹æ¥å¤„ç†ï¼Œè€Œä¸æ˜¯å‘é€åˆ°ç³»ç»Ÿæ¶ˆæ¯
 213   2              // msg = rfkey_event_to_msg(0, &e.u.key); // å°†ç³»ç»Ÿçš„æŒ‰é”®äº‹ä»¶è½¬æ¢ä¸ºè‡ªå®šä¹‰çš„æŒ‰é”®äº
             -‹ä»¶
 214   2              // printf("msg : %d\n", msg);
 215   2              // os_taskq_post_msg("rf_decode", 1, msg);
 216   2          }
 217   1          // else if (KEY_DRIVER_TYPE_24GHZ == scan_para->key_type)
 218   1          {
 219   2              // å¦‚æœæ˜¯2.4GHzé¥æ§å™¨æŒ‰é”®å¯¹åº”çš„äº‹ä»¶
 220   2              int msg = KEY_NULL; // å­˜æ”¾å¾…å‘é€çš„äº‹ä»¶ï¼ˆäº‹ä»¶æ¶ˆæ¯ï¼‰
 221   2      
 222   2              // e.u.key.event = key_event; // å­˜æ”¾æŒ‰é”®äº‹ä»¶ï¼ˆç”±ç³»ç»Ÿçš„æŒ‰é”®äº‹ä»¶æä¾›ï¼‰
 223   2              // e.u.key.value = key_value; // å­˜æ”¾å®é™…çš„é”®å€¼
 224   2      
 225   2              scan_para->click_cnt = 0; // å•å‡»æ¬¡æ•°æ¸…0
 226   2              scan_para->notify_value = NO_KEY;
 227   2              // å‘é€æ¶ˆæ¯ç»™åˆ°è‡ªå·±çš„çº¿ç¨‹æ¥å¤„ç†ï¼Œè€Œä¸æ˜¯å‘é€åˆ°ç³»ç»Ÿæ¶ˆæ¯
C51 COMPILER V9.60.7.0   AD_KEY                                                            12/09/2024 15:08:47 PAGE 5   

 228   2              // msg = remote_24ghz_event_to_msg(0, &e.u.key); // å°†ç³»ç»Ÿçš„æŒ‰é”®äº‹ä»¶è½¬æ¢ä¸ºè‡ªå®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶
 229   2              // os_taskq_post_msg("24g_decode", 1, msg);
 230   2          }
 231   1          // else // å¦‚æœä¸æ˜¯è‡ªå®šä¹‰çš„æŒ‰é”®å¯¹åº”çš„äº‹ä»¶
 232   1          {
 233   2              // key_value &= ~BIT(7);   // BIT(7) ç”¨ä½œæŒ‰é”®ç‰¹æ®Šå¤„ç†çš„æ ‡å¿—
 234   2              // e.type = SYS_KEY_EVENT; // ç³»ç»ŸæŒ‰é”®äº‹ä»¶
 235   2      
 236   2              // e.u.key.init = 1;
 237   2              // e.u.key.type = scan_para->key_type; // åŒºåˆ†æŒ‰é”®ç±»å‹
 238   2              // e.u.key.event = key_event;
 239   2              // e.u.key.value = key_value;
 240   2              // e.u.key.tmr = timer_get_ms();
 241   2      
 242   2              scan_para->click_cnt = 0; // å•å‡»æ¬¡æ•°æ¸…0
 243   2              scan_para->notify_value = NO_KEY;
 244   2      
 245   2              // e.arg = (void *)DEVICE_EVENT_FROM_KEY;
 246   2              /* printf("key_value: 0x%x, event: %d\n", key_value, key_event); */
 247   2              // if (key_event_remap(&e)) // æŒ‰é”®åŠŸèƒ½é‡æ˜ å°„ï¼Œç”¨äºå®ç°ç»„åˆæŒ‰é”®çš„åŠŸèƒ½
 248   2              // {
 249   2              //     // printf("-----------------function : %s %d\n", __FUNCTION__, __LINE__);
 250   2              //     // printf("key_value %u \nkey_event %d \n", key_value, key_event);
 251   2              //     sys_eventlabel_notify(&e);
 252   2              // }
 253   2          }
 254   1      
 255   1      label_scan_end:
 256   1          scan_para->last_key = cur_key_value; // ä¿å­˜ä¸Šä¸€æ¬¡æ‰«æåˆ°çš„é”®å€¼
 257   1          return;
 258   1      }
*** WARNING C280 IN LINE 26 OF ..\..\Hardware\ad_key.c: 'poweron_cnt': unreferenced local variable
 259          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    545    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
